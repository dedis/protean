package contracts

import (
	"bytes"
	"crypto/sha256"
	"github.com/dedis/protean/core"
	"go.dedis.ch/cothority/v3/byzcoin"
	"go.dedis.ch/cothority/v3/darc"
	"go.dedis.ch/kyber/v3/pairing"
	"go.dedis.ch/kyber/v3/sign"
	"go.dedis.ch/onet/v3/log"
	"go.dedis.ch/protobuf"
	"golang.org/x/xerrors"
)

var suite = pairing.NewSuiteBn256()

const ContractKeyValueID = "keyValue"

type Request struct {
	ExecReq    *core.ExecutionRequest
	InReceipts map[int]map[string]*core.OpcodeReceipt
	UID        string
	OpcodeName string
}

type ContractKeyValue struct {
	byzcoin.BasicContract
	core.Storage
}

func ContractKeyValueFromBytes(in []byte) (byzcoin.Contract, error) {
	cv := &ContractKeyValue{}
	err := protobuf.Decode(in, &cv.Storage)
	if err != nil {
		log.Errorf("Protobuf decode failed: %v", err)
		return nil, err
	}
	return cv, nil
}

func (c *ContractKeyValue) Spawn(rst byzcoin.ReadOnlyStateTrie, inst byzcoin.Instruction, coins []byzcoin.Coin) (sc []byzcoin.StateChange, cout []byzcoin.Coin, err error) {
	cout = coins
	var darcID darc.ID
	_, _, _, darcID, err = rst.GetValues(inst.InstanceID.Slice())
	if err != nil {
		log.Errorf("GetValues failed: %v", err)
		return
	}
	cs := &c.Storage
	for _, kv := range inst.Spawn.Args {
		cs.Store = append(cs.Store, core.KV{kv.Name, kv.Value})
	}
	csBuf, err := protobuf.Encode(&c.Storage)
	if err != nil {
		log.Errorf("Protobuf encode failed: %v", err)
		return
	}
	sc = []byzcoin.StateChange{
		byzcoin.NewStateChange(byzcoin.Create, inst.DeriveID(""), ContractKeyValueID, csBuf, darcID),
	}
	return
}

func (c *ContractKeyValue) Invoke(rst byzcoin.ReadOnlyStateTrie, inst byzcoin.Instruction, coins []byzcoin.Coin) (sc []byzcoin.StateChange, cout []byzcoin.Coin, err error) {
	cout = coins
	var darcID darc.ID
	iid := inst.InstanceID.Slice()
	kvd := &c.Storage

	if inst.Invoke.Command == "update" {
		pr, err := rst.GetProof(iid)
		if err != nil {
			log.Errorf("get proof failed: %v", err)
			return nil, nil, err
		}
		err = verifyRequest(iid, pr.GetRoot(), kvd, inst.Invoke.Args)
		if err != nil {
			return nil, nil, err
		}
	} else if inst.Invoke.Command != "init_contract" && inst.Invoke.
		Command != "dummy" {
		log.Errorf("value contract can only init_contract, update, " +
			"or dummy")
		return nil, nil, xerrors.New("invalid command")
	}

	_, _, _, darcID, err = rst.GetValues(iid)
	if err != nil {
		log.Errorf("Get values failed: %v", err)
		return
	}
	Update(kvd, inst.Invoke.Args)
	var buf []byte
	buf, err = protobuf.Encode(kvd)
	if err != nil {
		log.Errorf("Protobuf encode failed: %v", err)
		return
	}
	sc = []byzcoin.StateChange{
		byzcoin.NewStateChange(byzcoin.Update, inst.InstanceID, ContractKeyValueID, buf, darcID),
	}
	return
}

func (c *ContractKeyValue) Delete(rst byzcoin.ReadOnlyStateTrie, inst byzcoin.Instruction, coins []byzcoin.Coin) (sc []byzcoin.StateChange, cout []byzcoin.Coin, err error) {
	cout = coins
	var darcID darc.ID
	_, _, _, darcID, err = rst.GetValues(inst.InstanceID.Slice())
	if err != nil {
		log.Errorf("Get values failed: %v", err)
		return
	}

	sc = byzcoin.StateChanges{byzcoin.NewStateChange(byzcoin.Remove, inst.InstanceID, ContractKeyValueID, nil, darcID)}
	return
}

func Update(cs *core.Storage, args byzcoin.Arguments) {
	for _, kv := range args {
		var updated bool
		for i, stored := range cs.Store {
			if stored.Key == kv.Name {
				updated = true
				if kv.Value == nil || len(kv.Value) == 0 {
					cs.Store = append(cs.Store[0:i], cs.Store[i+1:]...)
					break
				}
				cs.Store[i].Value = kv.Value
			}
		}
		if !updated {
			cs.Store = append(cs.Store, core.KV{Key: kv.Name, Value: kv.Value})
		}
	}
}

func verifyRequest(iid []byte, contractRoot []byte, cs *core.Storage, args byzcoin.Arguments) error {
	req, err := getRequest(args)
	if err != nil {
		return err
	}
	// 1) Check if Merkle roots match
	if !bytes.Equal(req.ExecReq.EP.StateRoot, contractRoot) {
		err := xerrors.New("merkle roots do not match")
		log.Error(err)
		return err
	}
	// Get contract header
	hdr := &core.ContractHeader{}
	err = protobuf.Decode(cs.Store[1].Value, hdr)
	if err != nil {
		log.Errorf("retrieving contract header: %v", err)
		return err
	}
	// 2) Check that the CIDs match
	if !bytes.Equal(req.ExecReq.EP.CID, iid) || !bytes.Equal(req.ExecReq.EP.CID, hdr.CID[:]) {
		err := xerrors.New("inconsistent CID values")
		log.Error(err)
		return err
	}
	// 3) Check that writeset is generated by the correct code
	if !bytes.Equal(req.ExecReq.EP.CodeHash, hdr.CodeHash) {
		err := xerrors.New("code hashes do no match")
		log.Error(err)
		return err
	}
	// 4) verify execution request
	err = req.ExecReq.Verify(&core.VerificationData{UID: req.UID,
		OpcodeName: req.OpcodeName, InputHashes: prepareHashes(args)})
	if err != nil {
		log.Errorf("verifying execution request: %v", err)
		return err
	}
	// 5) verify input receipts
	inputMap := createInputMap(req.ExecReq)
	err = verifyInputReceipts(req.ExecReq, req.InReceipts, inputMap)
	if err != nil {
		return err
	}
	return nil
}

func getRequest(args byzcoin.Arguments) (*Request, error) {
	for _, arg := range args {
		if arg.Name == "request" {
			var req Request
			err := protobuf.Decode(arg.Value, &req)
			if err != nil {
				log.Errorf("protobuf decode: %v", err)
				return nil, err
			}
			return &req, nil
		}
	}
	return nil, xerrors.New("missing execution request")
}

func prepareHashes(args byzcoin.Arguments) map[string][]byte {
	h := sha256.New()
	for _, arg := range args {
		if arg.Name != "request" {
			h.Write([]byte(arg.Name))
			h.Write(arg.Value)
		}
	}
	hashes := make(map[string][]byte)
	hashes["ws"] = h.Sum(nil)
	return hashes
}

type pair struct {
	idx  int
	name string
}

func createInputMap(execReq *core.ExecutionRequest) map[pair][]pair {
	depMap := make(map[pair][]pair)
	for opIdx, opcode := range execReq.EP.Txn.Opcodes {
		for depName, dep := range opcode.Dependencies {
			if dep.Src == core.OPCODE {
				pKey := pair{idx: dep.Idx, name: dep.SrcName}
				pVal := pair{idx: opIdx, name: depName}
				pairs, ok := depMap[pKey]
				if ok {
					pairs = append(pairs, pVal)
				} else {
					depMap[pKey] = []pair{pVal}
				}
			}
		}
	}
	return depMap
}

// Note: This function is NOT tested! None of the applications have a
//transaction where an opcode output is passed to multiple opcode inputs.
//Therefore, in our experiments, the code inside the if-statement is never executed.
func verifyInputReceipts(execReq *core.ExecutionRequest,
	inReceipts map[int]map[string]*core.OpcodeReceipt,
	inputMap map[pair][]pair) error {

	for _, destPairs := range inputMap {
		if len(destPairs) > 1 {
			for i := 0; i < len(destPairs)-1; i++ {
				h1 := inReceipts[destPairs[i].idx][destPairs[i].name].HashBytes
				h2 := inReceipts[destPairs[i+1].idx][destPairs[i+1].name].HashBytes
				if !bytes.Equal(h1, h2) {
					log.Errorf("hashes do not match %d:%s and %d:%s",
						destPairs[i].idx, destPairs[i].name, destPairs[i+1].idx,
						destPairs[i+1].name)
					return xerrors.New("cannot verify input receipts")
				}
			}
			for _, pair := range destPairs {
				dfuid := execReq.EP.Txn.Opcodes[pair.idx].DFUID
				dfuData := execReq.EP.DFUData[dfuid]
				receipt := inReceipts[pair.idx][pair.name]
				err := receipt.Sig.VerifyWithPolicy(suite, receipt.Hash(),
					dfuData.Keys, sign.NewThresholdPolicy(dfuData.Threshold))
				if err != nil {
					log.Errorf("cannot verify sig: %v", err)
					return err
				}
			}
		}
	}
	return nil
}
